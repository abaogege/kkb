#   组件通信

##  父传子

-----------------------

+   属性props
 
------------------

+   引用refs
```js
//父组件
<HelloWorld ref='hw'></HelloWorld>

this.$refs.hw.a //test

//子组件HelloWorld
data(){
    return {
        a:'test'
    }
}

```
父组件通过 `vm.$refs.hw` 可以访问到子组件

注意：

1.  在生命周期 `created` 钩子里访问 `refs` 需要在  `nextTick`  内
```js
    //父组件
    created(){
        this.$refs.hw//undefined
        this.$nextTick(()=>{
            this.$refs.hw // component
        })
    }
```
2.  和 `v-for` 搭配使用时要注意生效时期
```js
//父组件
<HelloWorld v-for="(item,index) in list" :key="index" ref='hw'></HelloWorld>
    data() {
        return {
            list: []
        }
    },
    created() {
        setTimeout(() => {
            this.getList();
        }, 2000)
    },
    mounted() {
        console.log(this.$refs.hw);//undefined
        this.$nextTick(() => {
            console.log(this.$refs.hw);//undefined
        })
    },
    updated() {
         console.log(this.$refs.hw);//2s后输出component
    },
    methods(){
        getList() {
            this.list = ['a', 'b', 'c']
        }
    },
```
>   $refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。

----------------

+   子元素children

```js
    //父组件
    <HelloWorld ref='hw'></HelloWorld>
    this.$children[0].hw.a //test

    //子组件HelloWorld
    data(){
        return {
            a:'test'
        }
    }

```

注意：

1.  和 `$refs` 相似，在元素挂载后才可以访问
2.  子元素不保证顺序，即 `vm.$children` 这个数组的顺序不与dom顺序挂钩

---------------

##  子传父

-----------

+   自定义事件






--------------------

#   自定义组件的双向绑定

##  v-model语法糖

`v-model` 实际上是一个语法糖，是对 `:value` 和 `@input` 的封装

父组件index.vue
```html

<template>
    <div>
        <QInput v-model="userData"> </QInput>
        {{userData}}
    </div>
</template>

```

```js

import QInput from './QInput.vue';

export default {
    data(){
        return{
            userData:'abao'
        }
    },
    components: {
        QInput,
    },
}
```

子组件QInput
```html
<template>
    <input :value="value"  @input="onInput">
</template>
```
```js
export default {
   props: {
       value: {
           type: String,
           default: ''
       },
   },
   methods: {
       onInput(e) {
           this.$emit('input',e.target.value)
       }
   },
}
```
子组件每次输入的时候触发onInput事件，派发input事件到父组件，父组件的`v-model`写法其实相当于
```html
    <QInput :value = "userData" @input="userData = $event.target.value"> </QInput>
```


   




